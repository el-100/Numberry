Компилить в релизе без оптимизации.

Идея в том что по стандарту си, глобальные переменные можно объявлять без указания типа. В таком случае они будут интерпретироваться компилятором как int.
Это первое

 * Второе.
Имена переменных можно начинать с "_" или "$", а дальше ставить цифры. Получатся переменные вида _1, _21243124, $213

 * Третье - строки можно интерпретировать не только как массив байт, но и как массив 4-х байтных int'ов. Во втором случае нужно разобраться с LittleEndian
это пока что все очевидные вещи

 * Четвертое
Замена ключевых слов:
1) for - замена на рекурсию
2) if - условный тренарный оператор cond?then:else

Теперь к основному:
 * Пятое - PEB структура. Создаётся на этапе формирования процесса и живет до самого его завершения. Найдите способ обратиться к ней.
Могу лишь сказать, что её адрес находится в стеке. То есть нужно найти способ пройтись по стеку и по некоторой сигнатуре определить что это именно PEB. С помощью этой структуры можно опредилить базовый адрес любого подгруженного модуля(любой .dll'ки).
Определяем адрес kernel32.dll

С помощью хардкодных значений обращаемся к функции LoadLibraryA
и подгружаем библиотеку msvcr120.dll (тут вместо 120 нужно указать toolset установленной студии)

 * Шестое. И тут начинаются проблемы с декларациями о вызовах. Кто чистит стек вызывающий или вызываемый?
дело в том что из-за того что мы не можем указать декларацию явно (у нас нету букв), компилятором используется _cdecl, а kernel32.dll скомпилена с _stdcall.
Получается так что после вызова printf стек чистится два раза(перед выходом из функции и после), и это вызывает падение программы
и вот эту штуку я придумал как обойти двумя способами

1-й способ) Обход коррупции стека (чтобы не чистился два раза)
Цель: вызвать _stdcall функцию StdFunc(arg1, ..., argN) из функции CallFunc(..), с выделенными 4*N байт на аргументы, как _cdecl и оставить стек не поврежденным.
Решение:
Необходим враппер WrapFunc - _cdecl функция с количеством аргуметов N-1.
Первый аргумент - флаг, остальные смысловой нагрузки не несут и нужны для массовки, т.е. важен сам факт их наличия.

В теле WrapFunc условный оператор проверяет первый аргумент (т.е. флаг):
    при его равенстве нулю вызывается WrapFunc(1, ...), т.е. та же функция, но с установленым флагом в 1.
    при равенстве 1 вызывается StdFunc(...) с нужными аргументами.

Изначально вызывать следует WrapFunc(0, ...).
По условию указанному выше, WrapFunc(0, ...) вызывается из функции CallFunc()

Дело в том что когда StdFunc(...) возвращает значение, то она за собой чистит стек по _stdcall. Затем в WrapFunc(1, ...) ещё раз чистится стек StdFunc(...) по _cdecl.
И в результате получается, что при выходе из WrapFunc(1, ...), мы попадаем не в WrapFunc(0, ...), а в CallFunc()!
Потому что вторая очистка стека, затерла адрес возврата в WrapFunc(0, ...) и остановилась аккуратно перед адресом возврата в CallFunc(),
что безболезненно исключило одну функцию из стека, за счет сохранения его структуры.

Такой способ очень элегантен, т.к. реализуется все лишь одной строчкой в теле враппера.

2-й способ) попроще в понимании, но менее элегантен в реализации. Суть заключается в ручном восстановлении стека через шеллкод
В некоторой вспомогательной функции с четырьмя аргументами(так надо для того чтобы VirtualAlloc при двойном затирании не вышел из этой функции и оставил один из аргументов),
1) получаем адрес возврата через стек и записываем его в последний(4-й) аргумент (после двойной очистки стека за VirtualAlloc этот агрумент выживет)
2) вызываемый зараннее подготовленный VirtualAlloc с зараннее подготовленным массивом с шеллкодом "push [esp]", для того чтобы этот массив можно было исполнить (обход DEP)
3) четыре раза вызываем этот массив (таким образом мы восстановили стек)
4) возвращаем запомненый аргумент на место стека.
5) стек восстанослен.

6) теперь перед вызовом всех _stdcall функций заполняем стек по количеству аргументов, чтобы при двойной очистке стек нормализовался.

 * Седьмое. 
Теперь из msvcr120.dll можно хардкодно взять printf, scanf (тут все ок - _cdecl)

Ну и все






